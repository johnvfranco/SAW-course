import perm

// Sort algorithm: let lst be the list to sort and let acc initially be a
// sequence of 0s of the same length as lst.   In a round, elements of lst
// are compared with elements of acc, starting from the right (greatest
// elements first).  If the lst element is greater than the existing acc
// element, the acc element moves down by 1 and makes way for the lst
// element to ne placed in where the acc element had been.  If the lst
// element is not greater then it is placed before the acc element it is
// compared with.  This process has the effect that greater elements move
// one position to the right and the lesser elements one position to the
// left on a round.  Thus, running a number of rounds equal to the length
// of lst sorts lst.  Empty input list is not allowed.
round lst acc = (func lst ((length lst)-1) acc)
  where
    func lt i ac =
      if (i == -1)
		then ac
      else if ((last ac) == 0)
		     then func lt (i-1) (insert ac (lt@i) i) 
	        else if (lt@i) > (ac@(i+1))
                then func lt (i-1) (insert (insert ac (ac@(i+1)) i) (lt@i) (i+1))
                else func lt (i-1) (insert ac (lt@i) i)

// replace the ith element of sequence lst with the number m
insert lst m i = [ if k==i then m else x | x <- lst | k <- [0...]]

// Create a sequence of zeros equal in length to input sequence lst
makeZeros lst = [ 0 | i <- lst ]

// Sort a given input sequence lst - the a numbers of rounds equal to
// the length of lst
sort lst =  z ! 0
  where
    z = [ round x (makeZeros lst)  | x <- [lst]#z | i <- lst ]

// Returns True if and only if the sequence lst has no -1s and no 0s
valid lst = (z ! 0)
  where
    z = [True]#[(x > 0 /\ ~(x == -1)) /\ y | x <- lst | y <- z ]

// Theorem stating a valid sequence lst implies lst is a permutation
// of (sort lst)
isAPerm : [6][32] -> Bit
property isAPerm lst = if (valid lst) then perm lst (sort lst) else True

// Returns True if and only if for every pair of consecutive numbers in
// lst, the left number is never greater than the right number
nondecreasing : [6][32] -> Bit
nondecreasing lst = (res ! 0)
  where
    res = [True]#[ if (j1 <= j2) /\ k then True else False
                 | k <- res | j1 <- lst | j2 <- drop `{1} lst]

// Theorem stating a valid sequence lst implies the sequence (sort lst)
// is nondecreasing
sortIsOrdered : [6][32] -> Bit
property sortIsOrdered lst = if (valid lst) then nondecreasing (sort lst) else True

